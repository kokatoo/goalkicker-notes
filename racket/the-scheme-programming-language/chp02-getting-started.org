#+STARTUP: showeverything
#+title: The Scheme Programming Langauge

* Chapter 2. Getting Started

  Lexical scoping and block structure are features taken from Algol 60.
  Scheme was the first Lisp dialect to adopt lexical scoping and block
  structure, first-class procedures, the treatment of tail calls as jumps,
  continuations, and lexically scoped syntactic extensions.

** Exercise 2.2.1

   Convert the following arithmetic expressions into Scheme expressions and
   evaluate them.

#+begin_src racket
(+ (* 1.2 (- 2 1/3)) -8.7)
(/ (+ 2/3 4/9) (- 5/11 4/3))
(+ 1 (/ 1 (/ (+ 2 (/ 1 (+ 1 1/2))))))
(* 1 -2 3 -4 5 -6 7)
#+end_src

** Exercise 2.2.3

   Determine the values of the following expressions. Use your Scheme system to
   verify your answers.

#+begin_src racket
(cons 'car 'cdr)
(list 'this '(is silly))
(cons 'is '(this silly?))
(quote (+ 2 3))
(cons '+ '(2 3))
(car '(+ 2 3))
(cdr '(+ 2 3))
cons (quote cons)
(quote (quote cons))
(car (quote (quote cons)))
(+ 2 3)
(+ '2 '3)
(+ (car '(2 3))
   (car (cdr '(2 3))))
((car (list + - * /)) 2 3)
#+end_src

#+begin_src racket
'(car . cdr)
'(this (is silly))
'(is this silly?)
'(+ 2 3)
'(+ 2 3)
'+
'(2 3)
#<procedure:cons>
'cons
''cons
'quote
5
5
5
5
#+end_src

** Exercise 2.2.4

   ~(car (car '((a b) (c d))))~ yields ~a~. Determine which compositions of ~car~
   and ~cdr~ applied to ~((a b) (c d))~ yield ~b, c, and d~.

#+begin_src racket
(car (cdr (car '((a b) (c d)))))
(car (car (cdr '((a b) (c d)))))
(car (cdr (car (cdr '((a b) (c d))))))
#+end_src

** Exercise 2.2.5

   Write a Scheme expression that evaluates to the following internal list
   structure.

#+begin_src racket
'((a .b) ((c) d) ())
#+end_src

** Exercise 2.2.6

   Draw the internal list structure produced by the expression below.

#+begin_src racket
(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))
#+end_src

** Exercise 2.4.1

    Rewrite the following expressions, using let to remove common subexpressions
    and to improve the structure of the code. Do not perform any algebraic
    simplifications.

#+begin_src racket
(+ (- (* 3 a) b) (+ (* 3 a) b))
(let ([x (* 3 a)])
  (+ (- x b) (+ x b)))

(cons (car (list a b c)) (cdr (list a b c)))
(let ([x (list a bc)])
  (cons (car x) (cdr x)))
#+end_src

** Exercise 2.4.2

   Determine the value of the following expression. Explain how you derived this
   value.

#+begin_src racket
(let ([x 9])
  (display x)
  (newline)
  (* x
     (let ([x (/ x 3)])
       (display x)
       (newline)
       (+ x x))))
#+end_src

** Exercise 2.4.3

   Rewrite the following expressions to give unique names to each different
   let-bound variable so that none of the variables is shadowed. Verify that the
   value of your expression is the same as that of the original expression.

#+begin_src racket
(let ([x 'a] [y 'b])
  (list (let ([x 'c]) (cons x y))
        (let ([y 'd]) (cons x y))))

(let ([x0 'a] [y0 'b])
  (list (let ([x1 'c]) (cons x1 y0))
        (let ([y1 'd]) (cons x0 y1))))

(let ([x '((a b) c)])
  (cons (let ([x (cdr x)])
          (car x))
        (let ([x (car x)])
          (cons (let ([x (cdr x)])
                  (car x))
                (cons
                 (let ([x (car x)]) x)
                 (cdr x))))))

(let ([x0 '((a b) c)])
  (cons (let ([x1 (cdr x0)])
          (car x1))
        (let ([x2 (car x0)])
          (cons
           (let ([x3 (cdr x2)]) (car x3))
           (cons (let ([x4 (car x2)]) x4)
                 (cdr x2))))))
#+end_src



